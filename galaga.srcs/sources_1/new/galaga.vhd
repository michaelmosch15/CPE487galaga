-- ============================================================================
-- Top-Level Module: Galaga Game
-- ============================================================================
-- This module serves as the top-level entity that instantiates and connects
-- all sub-modules including the game engine, VGA controller, clock wizard,
-- and display drivers. It handles player input, converts data formats, and
-- routes signals between components.

-- ============================================================================

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.STD_LOGIC_ARITH.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;

ENTITY galaga IS
    PORT (
        -- Clock input from board oscillator
        clk_in : IN STD_LOGIC; -- 100 MHz system clock
        
        -- VGA display outputs (4-bit color depth for 4096 colors)
        VGA_red : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);   -- Red color channel
        VGA_green : OUT STD_LOGIC_VECTOR (3 DOWNTO 0); -- Green color channel
        VGA_blue : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);  -- Blue color channel
        VGA_hsync : OUT STD_LOGIC;  -- Horizontal sync signal
        VGA_vsync : OUT STD_LOGIC; -- Vertical sync signal
        
        -- User input buttons
        btnl : IN STD_LOGIC; -- Left button: move ship left
        btnr : IN STD_LOGIC; -- Right button: move ship right
        btn0 : IN STD_LOGIC; -- Center button: fire laser
        btnu : IN STD_LOGIC; -- Up button: reset game 
        
        -- Output displays
        led : OUT STD_LOGIC_VECTOR (15 DOWNTO 0);      -- LEDs for lives indicator (ADDED)
        SEG7_anode : OUT STD_LOGIC_VECTOR (7 DOWNTO 0); -- 7-segment digit select anodes
        SEG7_seg : OUT STD_LOGIC_VECTOR (6 DOWNTO 0)    -- 7-segment segment patterns (a-g)
    ); 
END galaga;

ARCHITECTURE Behavioral OF galaga IS
    -- ========================================================================
    -- Internal Signals
    -- ========================================================================
    
    -- Clock signals
    SIGNAL pxl_clk : STD_LOGIC := '0'; -- 25 MHz pixel clock for VGA (generated by clock wizard)
    
    -- Color signals: Game engine outputs 1-bit colors, VGA needs 4-bit
    SIGNAL S_red, S_green, S_blue : STD_LOGIC;  -- Single-bit color from game engine
    SIGNAL S_red_vec, S_green_vec, S_blue_vec : STD_LOGIC_VECTOR (3 DOWNTO 0); -- 4-bit vectors for VGA
    
    -- VGA sync and pixel coordinates
    SIGNAL S_vsync : STD_LOGIC;  -- Vertical sync from VGA module
    SIGNAL S_pixel_row, S_pixel_col : STD_LOGIC_VECTOR (10 DOWNTO 0); -- Current pixel coordinates (0-799 cols, 0-599 rows)
    
    -- Player position and controls
    SIGNAL player_pos : STD_LOGIC_VECTOR (10 DOWNTO 0) := CONV_STD_LOGIC_VECTOR(400, 11); -- Player X position (centered initially)
    SIGNAL count : STD_LOGIC_VECTOR (20 DOWNTO 0); -- Counter for button debouncing and 7-seg multiplexing
    SIGNAL shoot_signal : STD_LOGIC; -- Shoot button signal (directly connected to btn0)
    
    -- Score display signals
    SIGNAL score_binary : STD_LOGIC_VECTOR (15 DOWNTO 0); -- Binary score from game engine (0-65535)
    SIGNAL display : STD_LOGIC_VECTOR (15 DOWNTO 0); -- BCD score for 7-segment display (4 digits × 4 bits)
    SIGNAL led_mpx : STD_LOGIC_VECTOR (2 DOWNTO 0); -- Multiplexing selector for 7-segment digits (cycles 0-3)
    
    -- Lives indicator
    SIGNAL lives_out : STD_LOGIC_VECTOR(2 DOWNTO 0); -- Lives count from game (0-3)
    
    COMPONENT galaga_game IS
        PORT (
            v_sync : IN STD_LOGIC;
            pixel_row : IN STD_LOGIC_VECTOR(10 DOWNTO 0);
            pixel_col : IN STD_LOGIC_VECTOR(10 DOWNTO 0);
            player_x : IN STD_LOGIC_VECTOR (10 DOWNTO 0);
            shoot : IN STD_LOGIC;
            reset : IN STD_LOGIC;
            red : OUT STD_LOGIC;
            green : OUT STD_LOGIC;
            blue : OUT STD_LOGIC;
            score : OUT STD_LOGIC_VECTOR(15 DOWNTO 0);
            lives : OUT STD_LOGIC_VECTOR(2 DOWNTO 0);
            game_over : OUT STD_LOGIC
        );
    END COMPONENT;
    
    COMPONENT vga_sync IS
        PORT (
            pixel_clk : IN STD_LOGIC;
            red_in    : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
            green_in  : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
            blue_in   : IN STD_LOGIC_VECTOR (3 DOWNTO 0);
            red_out   : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
            green_out : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
            blue_out  : OUT STD_LOGIC_VECTOR (3 DOWNTO 0);
            hsync : OUT STD_LOGIC;
            vsync : OUT STD_LOGIC;
            pixel_row : OUT STD_LOGIC_VECTOR (10 DOWNTO 0);
            pixel_col : OUT STD_LOGIC_VECTOR (10 DOWNTO 0)
        );
    END COMPONENT;
    
    COMPONENT clk_wiz_0 IS
        PORT (
            clk_in1  : IN STD_LOGIC;
            clk_out1 : OUT STD_LOGIC
        );
    END COMPONENT;
    
    COMPONENT leddec16 IS
        PORT (
            dig : IN STD_LOGIC_VECTOR (2 DOWNTO 0);
            data : IN STD_LOGIC_VECTOR (15 DOWNTO 0);
            anode : OUT STD_LOGIC_VECTOR (7 DOWNTO 0);
            seg : OUT STD_LOGIC_VECTOR (6 DOWNTO 0)
        );
    END COMPONENT; 
    
BEGIN
    -- ========================================================================
    -- Player Movement Process
    -- ========================================================================
    -- Handles button debouncing and player ship movement. The count signal
    -- is used to debounce button inputs - movement only occurs when count = 0,
    -- preventing rapid position changes from button bounce. Player can move
    -- 5 pixels per button press, with boundaries at x=20 (left) and x=780 (right).
    player_movement : PROCESS (clk_in) IS
    BEGIN
        IF rising_edge(clk_in) THEN
            count <= count + 1; -- Increment counter for debouncing and multiplexing
            
            -- Move left: check button, debounce condition, and left boundary
            IF (btnl = '1' AND count = 0 AND player_pos > 20) THEN
                player_pos <= player_pos - 5;
            -- Move right: check button, debounce condition, and right boundary
            ELSIF (btnr = '1' AND count = 0 AND player_pos < 780) THEN
                player_pos <= player_pos + 5;
            END IF;
        END IF;
    END PROCESS;
    
    -- ========================================================================
    -- Button and Display Multiplexing
    -- ========================================================================
    shoot_signal <= btn0; -- Direct connection: shoot button fires immediately
    
    -- 7-segment display multiplexing: use bits 19-17 of count to cycle through
    -- digits 0-3. This creates a fast enough cycle (~1.2kHz) that all 4 digits
    -- appear to be lit simultaneously.
    led_mpx <= count(19 DOWNTO 17);
    
    -- ========================================================================
    -- Color Signal Conversion
    -- ========================================================================
    -- Game engine outputs single-bit color signals (on/off), but VGA interface
    -- requires 4-bit color vectors. We pad with zeros to create 4-bit values:
    -- '1' becomes "1000" (bright), '0' becomes "0000" (black).
    S_red_vec <= S_red & "000";
    S_green_vec <= S_green & "000";
    S_blue_vec <= S_blue & "000";
    
    -- ========================================================================
    -- Game Engine Component Instantiation
    -- ========================================================================
    -- The core game logic module. Receives pixel coordinates from VGA controller,
    -- player position and controls, and outputs color data and game state.
    game_inst : galaga_game
    PORT MAP(
        v_sync => S_vsync,           -- Vertical sync (60Hz) for game logic timing
        pixel_row => S_pixel_row,    -- Current pixel row (0-599)
        pixel_col => S_pixel_col,    -- Current pixel column (0-799)
        player_x => player_pos,      -- Player ship X position from movement process
        shoot => shoot_signal,       -- Fire button input
        reset => btnu,               -- Reset button (ADDED for this project)
        red => S_red,                -- Red color output (1-bit)
        green => S_green,            -- Green color output (1-bit)
        blue => S_blue,              -- Blue color output (1-bit)
        score => score_binary,       -- Binary score (0-65535)
        lives => lives_out,          -- Lives count (0-3)
        game_over => OPEN            -- Game over signal
    );
    
    -- ========================================================================
    -- LED Display Logic
    -- ========================================================================
    -- LEDs 13-15 indicate remaining lives. Each LED lights up when lives
    -- are at or above that threshold. This provides visual feedback without
    -- needing to look at the screen. LEDs 0-12 are unused (always off).
    -- ADDED for this project - not present in starter code.
    led(15) <= '1' WHEN lives_out >= "011" ELSE '0'; -- 3+ lives
    led(14) <= '1' WHEN lives_out >= "010" ELSE '0'; -- 2+ lives
    led(13) <= '1' WHEN lives_out >= "001" ELSE '0'; -- 1+ lives
    led(12 DOWNTO 0) <= (OTHERS => '0'); -- Unused LEDs always off
    
    -- ========================================================================
    -- VGA Sync Component Instantiation
    -- ========================================================================
    vga_driver : vga_sync
    PORT MAP(
        pixel_clk => pxl_clk,        -- 25 MHz pixel clock from clock wizard
        red_in => S_red_vec,         -- 4-bit red color input
        green_in => S_green_vec,     -- 4-bit green color input
        blue_in => S_blue_vec,       -- 4-bit blue color input
        red_out => VGA_red,          -- VGA red output (with blanking)
        green_out => VGA_green,      -- VGA green output (with blanking)
        blue_out => VGA_blue,        -- VGA blue output (with blanking)
        pixel_row => S_pixel_row,    -- Current pixel row (output to game)
        pixel_col => S_pixel_col,    -- Current pixel column (output to game)
        hsync => VGA_hsync,          -- Horizontal sync signal
        vsync => S_vsync             -- Vertical sync signal (also used by game)
    );
    VGA_vsync <= S_vsync; -- Route vsync to output port
        
    -- ========================================================================
    -- Clock Wizard Component Instantiation
    -- ========================================================================
    clk_wiz_0_inst : clk_wiz_0
    PORT MAP (
        clk_in1 => clk_in,   -- 100 MHz system clock input
        clk_out1 => pxl_clk  -- ~25 MHz pixel clock output
    );
    
    -- ========================================================================
    -- Binary-to-BCD Conversion Process
    -- ========================================================================
    -- Converts 16-bit binary score (0-65535) to 4-digit BCD format for
    -- 7-segment display. This ensures decimal display (0-9 per digit) instead
    -- of hexadecimal (0-F). Process is combinational - updates whenever
    -- score_binary changes. ADDED for this project.
    binary_to_bcd : PROCESS (score_binary)
        VARIABLE bin_val : INTEGER;  -- Binary score as integer
        VARIABLE bcd_val : STD_LOGIC_VECTOR(15 DOWNTO 0); -- BCD output (4 digits × 4 bits)
        VARIABLE digit0, digit1, digit2, digit3 : INTEGER; -- Individual decimal digits
    BEGIN
        -- Convert binary vector to integer for arithmetic operations
        bin_val := CONV_INTEGER(score_binary);
        
        -- Extract each decimal digit using modulo and division
        digit0 := bin_val MOD 10;              -- Ones place (0-9)
        digit1 := (bin_val / 10) MOD 10;       -- Tens place (0-9)
        digit2 := (bin_val / 100) MOD 10;      -- Hundreds place (0-9)
        digit3 := (bin_val / 1000) MOD 10;     -- Thousands place (0-9)
        
        -- Pack digits into BCD format: 4 bits per digit
        bcd_val(3 DOWNTO 0) := CONV_STD_LOGIC_VECTOR(digit0, 4);  -- Digit 0 (ones)
        bcd_val(7 DOWNTO 4) := CONV_STD_LOGIC_VECTOR(digit1, 4);  -- Digit 1 (tens)
        bcd_val(11 DOWNTO 8) := CONV_STD_LOGIC_VECTOR(digit2, 4); -- Digit 2 (hundreds)
        bcd_val(15 DOWNTO 12) := CONV_STD_LOGIC_VECTOR(digit3, 4); -- Digit 3 (thousands)
        
        display <= bcd_val; -- Output BCD value to 7-segment display
    END PROCESS;
    
    -- ========================================================================
    -- 7-Segment Display Component Instantiation
    -- ========================================================================
    led1 : leddec16
    PORT MAP(
        dig => led_mpx,      -- Digit selector (0-3) from multiplexing counter
        data => display,     -- 16-bit BCD data (4 digits × 4 bits)
        anode => SEG7_anode, -- Anode enable signals (one digit active at a time)
        seg => SEG7_seg      -- 7-segment pattern (a-g) for current digit
    );
END Behavioral;

